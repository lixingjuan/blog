 

# js是单线程？

## js为什么单线程

这个和js的工作有关，js主要工作在浏览器，而浏览器的主要工作是实现用户交互，效果呈现，如果一个线程在一个DOM节点修改内容，另一个线程删除了该DOM节点，此时应该以谁为主？此时就会引起冲突
于是js采用单线程的运行机制；

为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript 创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。
所以该标准并没有改变js单线程的本质；




## 任务队列

单线程就意味着所有任务都需要排队，前一个任务执行完，才会执行下一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
但是这种机制导致很多时候，CPU都是空闲的。因为IO设备很慢（比如网络请求），CPU会一直等待结果出来，再往下执行计算。
这样造成CPU大量时间都是等待过程，由于js的解析机制是从上向下按顺序解析，如果网络卡顿，就会堵塞页面渲染；


于是js语言的设计者意识到，这时主线程完全可以不管IO设备，挂起等待中的任务，先运行排在后面的任务，等IO设备返回了结果，再回过头执行挂起的任务。

于是，所有的任务可以分为两种：**同步任务** 和 **异步任务**；

同步任务指的是，在**主线程**上排队执行的任务，只有当前一个任务执行完毕，才会执行下一个任务；
异步任务指的是，不进入主线程，而进入任务队列（task queue）的任务, 只有任务队列通知主线程异步任务可以执行了，该异步任务才会进入主线程；



异步执行的运行机制

1. 所有同步任务都在主线程上执行，形成一个执行栈；
2. 主线程之外，还存在一个 “任务队列”， 只要异步任务有了结果，就在任务队列放置一个任务；
3. 一旦执行栈的同步任务执行完毕，主线程就会读取 “任务队列” ，异步任务就结束等待状态，进入执行站，开始执行；
4. 循环以上三个步骤；

主线程从 “任务队列” 读取任务的这个过程是源源不断的，所有这个过程称为event Loop


时间循环有一个或多个任务队列。任务队列是一组任务。
任务队列是集合，而不是队列。因为时间循环模型的任务是从选择的任务队列中抓取第一个可运行的任务，而不是排队的第一个任务；
微任务队列不是任务队列；


## 事件和回调函数

任务队列实际上是一个事件队列，主线程读取任务队列，就是读取里面有哪些事件。

“任务队列” 中的事件，除了IO设备的事件意外，还包括一些用户产生的事件（鼠标点击，页面滚动等等），只要指定过回调函数，这些事件发生时就会进入任务队列，等待主线程读取。

所谓回调函数，就是会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

“任务队列”是一个先进先出的执行顺序，只要执行栈一空，“任务队列”第一位的事件就自动进入主线程，但是由于存在“定时器”功能，主线程首先会检查下执行时间，某些事件只有到了规定的时间，才能返回主线程；


## 定时器

setTimeout()只是将事件插入到“任务队列”，必须等到当前执行栈代码执行完毕，才会去执行他指定的回调函数，如果当前代码耗时特别久，那setTimeout()的回调函数可能要等很久，所以并不能保证回调函数一定会在其指定的时间执行。

# Node.js

## Node的执行机制
Node.js也是单线程的Event Loop, 但是他的执行机制和js不同，
1. v8解析js脚本；
2. 解析后的代码，调用Node API；
3. libuv负责Node API的执行, 然后**将不同的任务分给不同线程**，形成一个eventLoop, 以异步的方式将任务的执行结果返回给V8引擎；
4. v8引擎将结果返回给用户；

## “任务队列”相关方法

== process.nextTick: ==
在当前“执行栈”之后，下一次 Eventloop (主线程读取“任务队列”) 发生之前触发回调函数，也就是他指定的任务总是发生在所有异步任务发生之前；

== setImmediate: ==
在当前“任务队列” 尾部添加事件，也就是会说他指定的时间在下一个 Eventloop 发生，作用类似setTimeout(fn, 0)；

