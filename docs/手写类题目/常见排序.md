常见的排序算法有

1. 快速排序
2. 冒泡排序
3. 选择排序
4. 插入排序
5. 归并排序
6. 希尔排序ddd


## 快速排序

### 算法

采用分治法策略，将一个数列分成两个数列

1. 从数列中挑取一个元素，称为“基准”；
2. 重新排列数列，所有比基准小的放在基准前面，所有比基准大的放在基准后面（相同的数可以到任一边），在这个分区退出之后，基准就位于数列的中间。这个称为分区操作；
3. 递归的将小于基准的子数列和大于基准的子数列进行排序；
4. 最后每个子数列分区仅剩一个元素则停止；



### 基础实现1


```js
const quickSort = (array) => {
  const sort = (arr, leftIndex = 0, rightIndex = arr.length - 1) => {
    if (leftIndex >= rightIndex) {
      // 如果左边的索引大于等于右边的索引说明整理完毕
      return;
    }
    let left = leftIndex;
    let right = rightIndex;
    const baseVal = arr[right]; // 取无序数组最后一个数为基准值

    while (left < right) {
      // 把所有比基准值小的数放在左边大的数放在右边
      while (left < right && arr[left] <= baseVal) {
        // 找到一个比基准值大的数交换
        left++;
      }
      arr[right] = arr[left]; // 将较大的值放在右边如果没有比基准值大的数就是将自己赋值给自己（left 等于 right）
      while (right > left && arr[right] >= baseVal) {
        // 找到一个比基准值小的数交换
        right--;
      }
      arr[left] = arr[right]; // 将较小的值放在左边如果没有找到比基准值小的数就是将自己赋值给自己（i 等于 right）
    }
    arr[right] = baseVal; // 将基准值放至中央位置完成一次循环（这时候 right 等于 i ）
    sort(arr, leftIndex, right - 1); // 将左边的无序数组重复上面的操作
    sort(arr, right + 1, rightIndex); // 将右边的无序数组重复上面的操作
  };
  const newArr = array.concat(); // 为了保证这个函数是纯函数拷贝一次数组
  sort(newArr);
  return newArr;
};
```


### 基础实现2

1. 选取一个基数用于比较，（选取第一个元素作为基数）;
2. 声明两个数组，分别是left, right;
3. 循环遍历该数组除了基数外的其他元素，大于等于基础放在right, 小于基数放在left;
4. 对数组left和right递归调用函数自身，直至left和right均只剩下一个元素；

> 但是网上看到有人说这个不算快排，每次递归都开辟了新的内存空间

```js
function quickSort1(array) {
  if (array.length < 2) {
    return array;
  }
  const target = array[0];
  let left = [];
  let right = [];
  for (let i = 1; i < array.length; i++) {
    if (array[i] < target) {
      left.push(array[i]);
    } else {
      right.push(array[i]);
    }
  }
  return [...quickSort1(left), target, ...quickSort1(right)];
}
```







## 冒泡排序

### 算法

重复的走访要排序的数列，每次比较相邻两个元素，若他们位置错误，就交换他们的位置；
走访数列的工作重复进行，直到再也没有元素需要交换位置，也就是说该排序已经完成。
在该算法中，越小的元素会经由交换，慢慢 “浮” 到数列的前端，所以叫冒泡排序；

描述：
1. 比较两个相邻元素，如果第一个大于第二个，则交换位置；
2. 对每一对 ==相邻元素== 做同样的操作，除了最后一个；（这样一轮下来，最大的元素就位于数列的尾部）
3. 重复以上步骤

### 基本写法

1. 外层扫描趟数是（数组长度 - 1）
   1. 例如：length 为3的数组，最多需要扫描两趟;
   2. 每趟扫描都会从未排序数列中获取一个最大元素位于未排序数列尾部;（1趟1个，2趟2个...n趟n个）


2. 内层的循环次数 => 数组长度-当前外层循环的次数(即不需要再比较尾部已经有序的部分)
   1. 例如：数组长度为5:
   2. 当前第1轮扫描完成后，最后1个元素为最大，下次扫描就只需要比较前面4个元素，即下次需要内层循环比较3次；
   3. 当前第2轮扫描完成后，最后2个元素为最大，下次扫描就只需要比较前面3个元素，即下次需要内层循环比较2次；


```js
/* 1. 基本写法 */
function bubbleSort(array) {
  // 外层循环次数即数组长度减1
  let times = array.length - 1;
  while (times) {
    // 内层循环次数即未排序元素个数减1
    for (let j = 0; j < times; j++) {
      if (array[j] > array[j + 1]) {
        [array[j], array[j + 1]] = [array[j + 1], array[j]];
      }
    }
    times--;
  }

  return array;
}
```


### 优化

- 针对：

数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到arr.length-1次，后面的比较没有意义的；

- 方案：

设置标志位flag，如果本轮发生了交换flag设置为true；如果没有交换就设置为false；
这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去；

```js
function bubbleSort(array) {
  let times = array.length - 1;
  while (times) {
    let flag = false;
    // 内层循环次数即未排序元素个数减1
    for (let j = 0; j < times; j++) {
      if (array[j] > array[j + 1]) {
        [array[j], array[j + 1]] = [array[j + 1], array[j]];
        flag = true;
      }
    }
    if (!flag) {
      break;
    }
    times--;
  }

  return array;
}
```



### 性能

(n=arr.length)

1. 时间复杂度：
   1. 最好情况下 => 数列为顺序排列，一趟扫描即可完成排序，比较次数n-1，移动次数0，时间复杂度为 O(n);
   2. 最坏情况下 => 数列为反序，每趟排序要 `n(n-1)/2` 次比较, `3n(n-1)/2` 次移动，最坏时间复杂度为 O(n2);
   3. 平均时间复杂度 =>  O(n2);
2. 稳定性：
> 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法


## 选择排序

### 算法

1. 该排序需要 `arr.length-1` 趟循环
2. 每趟循环都是为了找到待排序数列中的最小数，并放在已排序列表末尾


### 基础实现

1. 外层循环控制重复次数
2. 待排序列表的第一个元素作为基准，对待排序数列进行循环，每个元素与基准比较，找到最小数并保存其索引;
3. 将 `最小数` 放在待排序列表的第一个位置，即已排序数列的最后一个位置



```js
function selectionSort(arr) {
  const times = arr.length;

  for (let i = 0; i < times - 1; i++) {
    let minIndex = i;
    // 内层循环是为了找到未排序列表中最小数
    for (let j = i + 1; j < times; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j; // 保存最小数的索引
      }
    }
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
  }

  return arr;
}
```

### 性能
1. 时间复杂度：
   1. 选择排序的交换操作介于 0 和 (n - 1)次之间。选择排序的比较操作为 n(n - 1/2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。比较次数O(n^2），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+...+1=n*(n-1）/2。交换次数O(n）;
   2. 最好情况是，已经有序，交换0次；
   3. 最坏情况交换n-1次，逆序交换n/2次。
2. 交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快

> 选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法；


## 插入排序

### 算法


插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而产生一个新的、记录数增1的有序表。
在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。




### 基础实现


1. 从 `index===1` 的元素开始，取当前元素作为基准;
2. 从后向前扫描当前元素之前的数列，将每个元素与基准作比较:
   - 若当前元素大于基准，将该元素向后挪位(为最新元素提供插入空间);
   - 若当前元素小于基准，则将基准插入该元素后面，并停止扫描

```js
function insertionSort(arr) {
  const times = arr.length;
  for (let keyIndex = 1; keyIndex < times; keyIndex++) {
    let keyNumber = arr[keyIndex];
    let j = keyIndex - 1;
    while (j >= 0 && arr[j] > keyNumber) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = keyNumber;
  }

  return arr;
}
```

### 复杂度

1. 时间复杂度：
   1. 最好的情况 => 待排序数组是有序的，每趟循环只需要当前数与前面元素比较一次，该情况下一共需要比较 n-1 次，时间负责度为 O(N);
   2. 最坏的情况 => 待排序数组是逆序的，需比较总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为 O(N^2);
2. 空间复杂度：常数阶 O(1)





## 希尔排序

```js
function ShellSort(arr) {
  let len = arr.length;
  for (
    var fraction = Math.floor(len / 2);
    fraction > 0;
    fraction = Math.floor(fraction / 2)
  ) {
    for (var i = fraction; i < len; i++) {
      for (
        var j = i - fraction;
        j >= 0 && arr[j] > arr[fraction + j];
        j -= fraction
      ) {
        [arr[j], arr[fraction + j]] = [arr[fraction + j], arr[j]];
      }
    }
  }
  return arr;
}
```
## other

### 什么叫稳定排序？

待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中Ri领先于Rj（即i<j）
若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的。
比如int数组[1,1,1,6,4]中a[0],a[1],a[2]的值相等，在排序时不改变其序列，则称所用的方法是稳定的